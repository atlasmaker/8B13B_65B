/*
Copyright (c) 2021, 2022, 2023 and 2024 Tokio Yukiya  
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright notice, 
  this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, 
  this list of conditions and the following disclaimer in the documentation 
  and/or other materials provided with the distribution.
* Neither the name of the Tokyo Polytechnic University  nor the names of its contributors 
  may be used to endorse or promote products derived from this software 
  without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
OF THE POSSIBILITY OF SUCH DAMAGE.
*/


`timescale 1 ns / 1 ps

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

///////////////////////////////////////////////////
`define U8B13B_PREAMBLE        16'b1010101010101010
`define U8B13B_PREAMBLE_MSB    15
`define U8B13B_NUM_PREAMBLE    16
`define U8B13B_STARTBIT        4'b1111
`define U8B13B_STARTBIT_LENGTH 4
`define U8B13B_STOPBIT         7'b0000000


//This File is generated DEFINE.xlsx
`include<8B13B.h>

`define	U8B13B_IDLE							4'd0
`define	U8B13B_INITIAL						4'd1
`define	U8B13B_CREATE_PREAMBLE			4'd2
`define	U8B13B_CREATE_PREAMBLE_SHIFT	4'd3
`define	U8B13B_CREATE_BODY					4'd4
`define	U8B13B_CREATE_BODY_SHIFT			4'd5
`define	U8B13B_CREATE_CRC					4'd6
`define	U8B13B_CREATE_PACKET_0			4'd7
`define	U8B13B_CREATE_PACKET_1			4'd8
`define	U8B13B_SEND							4'd9
`define	U8B13B_TERMINATE					4'd10
`define	U8B13B_SEGMENT						13
`define	U8B13B_SEGMENT_MSB					12
`define	U8B13B_SEGMENT_SRC					8
////////////////////////////////////////////////////////////////////////////////////////////////////		
////		
////		
`define	 U8B13B_CRCMAN	48
`define	 U8B13B_CRCMAN_MSB	47
`define	 U8B13B_BITLENGTH	913
`define	 U8B13B_BITLENGTH_MSB	912
`define	 U8B13B_DATALENGTH	520
`define	 U8B13B_DATALENGTH_MSB	519
`define	 U8B13B_DATABITLENGTH	845
`define	 U8B13B_DATABITLENGTH_MSB	844
`define	RECV_DATALENGTH	520
`define	RECV_DATALENGTH_MSB	519
`define	RECV_DATALENGTHplusCRC_NUMPOLY	536

////		
`define	DATA_LENGTH	845
`define	CRC_NUMBITS	844
`define	DATA_CRC_RESET	861'd0
`define	DATA_CRC	861    //65Byte * 13bit(8B13B) +16bit(CRC)
`define	DATA_CRC_MSB	860
`define	DATA_CRC_MAN	893
`define	DATA_CRC_MAN_MSB	892
`define	DATA_CRC_MAN_RESET	893'b0
////////////////////////////////////////////////////////////
`define	CRC_NUMPOLY							16
`define	CRC_IDLE								4'd0
`define	CRC_DATASET							4'd1
`define	CRC_INITIAL							4'd2
`define	CRC_SHIFT							4'd3
`define	CRC_DATA_STORE						4'd4
`define	CRC_STROBE							4'd5
`define	CRC_STOP								4'd6
`define	CRC_FACTOR							17'b10001000000100001
`define	CRC_COF								16'b0
//`define	CRC_COF	
//////////////////////////////////////////////////////////////////////////////////////////		
`define	DECODE_INITIAL						4'd0
`define	DECODE_IDLE							4'd1
`define	DECODE_CONV							4'd2
`define	DECODE_CALC							4'd3
`define	DECODE_TERM							4'd4
//////////////////////////////////////////////////////////////////////////////////////////		
`define	CYCLE									10
`define	INITIAL_RESET						4'd0
`define	DETECT_INDATA						4'd1
`define	PREAMBLE_CHECK						4'd2
`define  BLANK									4'd3
`define	COUNTING_START_BIT_0				4'd4
`define	COUNTING_START_BIT_1				4'd5
`define	COUNTING_START_BIT_2				4'd6
`define	COUNTING_START_BIT_3				4'd7
`define	RECEIVE_DATA_0						4'd8
`define	RECEIVE_DATA_1						4'd9
`define	RECEIVE_DATA_2						4'd10
`define	DECODING_0							4'd11
`define	DECODING_1							4'd12
`define	DECODING_2							4'd13
`define	PRETERMINATE						4'd14
`define	TERMINATE							4'd15

//////////////SPI_RECEIVE_STATE //////////////
`define	SPI_SEND_INIT						4'd0
`define	SPI_SEND_WAIT					   4'd1
`define	SPI_SEND_DATA_REQ1				4'd2
`define	SPI_SEND_DATA_REQ2				4'd3
`define	SPI_SEND_WAIT_DONE0				4'd4
`define	SPI_SEND_DONE1						4'd5
`define	SPI_SEND_DONE2						4'd6
`define	SPI_SEND_DONE3						4'd7
`define	SPI_SEND_PREEND0					4'd8
`define	SPI_SEND_PREEND1					4'd9
`define	SPI_SEND_END						4'd10
		
`define	COUNT_START_BIT_ERROR			8'd30 //8'd11
`define	IDLE									2'd0
`define	SET									2'd1
`define	SEND									2'd2
`define	PREAMBLE								16'b1010101010101010
`define	NUM_PREAMBLE						16
`define	STARTBIT								4'b1111
`define	NUM_STARTBIT						4
`define	STOPBIT								7'b0000000
`define	NUM_STOPBIT							7

`define TXRX_SEND_PKT  1'b0
`define TXRX_RECV_SPI  1'b1
`define PW_REQ  8'd255 //8'd160  //8'd80    // pulse width of data_req and receive_req

///////////////////////////////////////////////////////////////////////////

module DelayFF (in_data, Q,clk);
input in_data;
input clk;
output Q;
reg Q=1'b0;
always @(posedge clk) begin
Q<=in_data;
end
endmodule


module Divider2 (clk,sig);
input clk;
output sig;
reg sig,sig_q;
initial begin sig=1'b0;sig_q=1'b1;end
always @(negedge clk) begin  sig_q=sig;end
always @(posedge clk) begin  sig<=~sig_q;end
endmodule

module Divider4 (clk,sig);
input clk;
output sig;
reg sig,sig_q;
reg [1:0] cnt,cnt_q;
initial begin sig=1'b0; cnt=2'b0; end

always @(negedge clk) begin
	sig_q<=sig;
   cnt_q<=cnt;
end

always @(posedge clk) begin 
	if(cnt_q==2'b0) begin
		sig<=~sig_q;
	end else begin 
	end
	cnt<=cnt_q+2'b1;
end
endmodule

module Divider8 (clk,sig);
input clk;
output sig;
reg sig,sig_q;
reg [2:0] cnt,cnt_q;
initial begin sig=1'b0;sig_q=1'b0; cnt=3'b0; cnt_q=3'b0; end

always @(negedge clk) begin 
	sig_q<=sig;
   cnt_q<=cnt;
end

always @(posedge clk) begin 
	if(cnt_q==3'b0) begin
		sig<=~sig_q;
	end else begin 
	end
	cnt<=cnt_q+3'b1;
end
endmodule

///////////////////////////////////////
//////// Clock Shift //////////////////
///////////////////////////////////////
module Divider8Shift(clk, sig, accel, delay);
input clk;
output sig;
input accel;
input delay;
reg [3:0] cnt,cnt_q,add,dec;
reg sig,sig_q,reset;
initial begin 
sig=1'b1;
reset=1'b0;
add=4'b0;
dec=4'b0;
cnt=4'b0;
sig_q=1'b0;
cnt_q=4'b0;
end

always @(posedge accel or posedge delay or posedge reset) begin
casex ({accel,delay,reset})
3'bxx1:  begin add<=4'b0; dec<=4'b0;  end
3'b100:  begin add<=4'd1; dec<=4'b0;  end
3'b010:  begin add<=4'b0; dec<=4'd1;  end
default: begin add<=4'b0; dec<=4'b0;  end
endcase
end


always @(negedge clk) begin
cnt_q<=cnt;
sig_q<=sig;
end

always @(posedge clk) begin
reset<=1'b0; 
if((cnt_q)==(3'd7-add+dec)) begin 
    sig<=~sig_q;
    reset<=1'b1;
    cnt<=4'b0; 
end else begin cnt<=cnt_q+4'b1; end
end

endmodule

////////////////////////////////////////////////////////
module DelaySelector32(clk,sigs,sel,twice_sig,lock);
input clk;
input [31:0]sigs;
output [5:0]sel;
output lock;
input twice_sig;
reg [5:0] sel,sel_q;
reg lock;

initial begin 
lock=1'b0; 
sel=6'b0;
sel_q=6'b0;
end
//////////////////////////////////
/////// DelaySelector32 //////////
//////////////////////////////////
function [5:0] DelaySelector32(input [31:0] sigs); // Negative Edge
begin
casex (sigs)	
		32'b1111111x000000000xxxxxxxxxxxxxxx: begin  DelaySelector32=6'd31; end //0
		32'bx1111111x000000000xxxxxxxxxxxxxx: begin  DelaySelector32=6'd30; end //0
		32'bxx1111111x000000000xxxxxxxxxxxxx: begin  DelaySelector32=6'd29; end //0
		32'bxxx1111111x000000000xxxxxxxxxxxx: begin  DelaySelector32=6'd28; end //0
		32'bxxxx1111111x000000000xxxxxxxxxxx: begin  DelaySelector32=6'd27; end //0
		32'bxxxxx1111111x000000000xxxxxxxxxx: begin  DelaySelector32=6'd26; end //0
		32'bxxxxxx1111111x000000000xxxxxxxxx: begin  DelaySelector32=6'd25; end //0
		32'bxxxxxxx1111111x000000000xxxxxxxx: begin  DelaySelector32=6'd24; end //0
		32'bxxxxxxxx1111111x000000000xxxxxxx: begin  DelaySelector32=6'd23; end //0
		32'bxxxxxxxxx1111111x000000000xxxxxx: begin  DelaySelector32=6'd22; end //0
		32'bxxxxxxxxxx1111111X000000000xxxxx: begin  DelaySelector32=6'd21; end //0
		32'bxxxxxxxxxxx1111111x000000000xxxx: begin  DelaySelector32=6'd20; end //0
		32'bxxxxxxxxxxxx1111111x000000000xxx: begin  DelaySelector32=6'd19; end //0
		32'bxxxxxxxxxxxxx1111111x000000000xx: begin  DelaySelector32=6'd18; end //0
		32'bxxxxxxxxxxxxxx1111111x000000000x: begin  DelaySelector32=6'd17; end //0
		32'bxxxxxxxxxxxxxxx1111111x000000000: begin  DelaySelector32=6'd16; end //0		
		32'b000000000x1111111xxxxxxxxxxxxxxx: begin  DelaySelector32=6'd15;  end //12
		32'bx000000000x1111111xxxxxxxxxxxxxx: begin  DelaySelector32=6'd14;  end //11
		32'bxx000000000x1111111xxxxxxxxxxxxx: begin  DelaySelector32=6'd13;  end //10
		32'bxxx000000000x1111111xxxxxxxxxxxx: begin  DelaySelector32=6'd12;  end //9
		32'bxxxx000000000x1111111xxxxxxxxxxx: begin  DelaySelector32=6'd11;  end //8
		32'bxxxxx000000000x1111111xxxxxxxxxx: begin  DelaySelector32=6'd10;  end //7
		32'bxxxxxx000000000x1111111xxxxxxxxx: begin  DelaySelector32=6'd9;  end //6
		32'bxxxxxxx000000000x1111111xxxxxxxx: begin  DelaySelector32=6'd8;  end //5
		32'bxxxxxxxx000000000x1111111xxxxxxx: begin  DelaySelector32=6'd7; end //4
		32'bxxxxxxxxx000000000x1111111xxxxxx: begin  DelaySelector32=6'd6; end //3
		32'bxxxxxxxxxx000000000x1111111xxxxx: begin  DelaySelector32=6'd5; end //2
		32'bxxxxxxxxxxx000000000x1111111xxxx: begin  DelaySelector32=6'd4; end //1
		32'bxxxxxxxxxxxx000000000x1111111xxx: begin  DelaySelector32=6'd3; end //0
		32'bxxxxxxxxxxxxx000000000x1111111xx: begin  DelaySelector32=6'd2; end //0
		32'bxxxxxxxxxxxxxx000000000x1111111x: begin  DelaySelector32=6'd1; end //0
		32'bxxxxxxxxxxxxxxx000000000x1111111: begin  DelaySelector32=6'd0; end //0
default: begin DelaySelector32= 6'b111111; end	
endcase
end
endfunction


always @(negedge clk) sel_q<=sel;
 
always @(posedge twice_sig) begin 
		sel<=DelaySelector32(sigs);
		if(sel_q!= 6'b111111) lock<=1'b1;  else lock<=1'b0;
end

endmodule
//////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
module CRC (data_in, poly,cof,start,ck,busy,result,strobe,bits,data_crc,reset);
input [`CRC_NUMBITS:0] data_in; //447:0
input [`CRC_NUMPOLY:0] poly;
input [`CRC_NUMPOLY-1:0] cof;
input ck,start,reset;
output [(`CRC_NUMPOLY-1):0] result;
output [(`CRC_NUMBITS+`CRC_NUMPOLY):0] bits, data_crc;
output strobe,busy;

// if you want to create the crc_bits, input 0 to cof.
// if you want to check the crc_bits, input crc code to cof and data is into data_in. 

reg [(`CRC_NUMBITS+`CRC_NUMPOLY):0] poly_CRC_SHIFT,poly_CRC_SHIFT_q,data,data_q,result_bits,result_bits_q; // 
reg [3:0] status,status_q;
reg [9:0] p,p_q;
reg [7:0] cnt,cnt_q;
reg strobe,busy;
integer i;

assign bits = poly_CRC_SHIFT;
assign data_crc = result_bits;
assign result = data[(`CRC_NUMPOLY-1):0]; // RESULT!!!!
initial begin
status = `CRC_IDLE;
busy=1'b0;
strobe=1'b0;
p=10'b0;
p_q=10'b0;
poly_CRC_SHIFT=`DATA_CRC_RESET;
poly_CRC_SHIFT_q=`DATA_CRC_RESET;
result_bits<=`DATA_CRC_RESET;
result_bits_q<=`DATA_CRC_RESET;
cnt=8'b0;
cnt_q=8'b0;
status=`CRC_IDLE;
status_q= `CRC_IDLE;
end

always @(negedge ck)begin
p_q<=p;
cnt_q<=cnt;
data_q<=data;
result_bits_q<=result_bits ; 
poly_CRC_SHIFT_q<=poly_CRC_SHIFT;
status_q<=status;
end


always @(posedge ck) begin
case (status_q)
`CRC_IDLE: begin  
	if(start == 1'b1) begin 
		status <= `CRC_DATASET; 
		strobe<=1'b0;
		data <= data_in;
		result_bits <= data_in;
		poly_CRC_SHIFT <= poly;
		p<=10'b0; 
	end else begin 
		strobe<=1'b0;
	end  
end
`CRC_DATASET: begin 
	data <= data_q <<`CRC_NUMPOLY;
	result_bits <= result_bits_q <<`CRC_NUMPOLY;
	status <= `CRC_INITIAL;                
	busy=1'b1;
end
`CRC_INITIAL: begin  
	data[`CRC_NUMPOLY-1:0] <= cof;  
	poly_CRC_SHIFT <= poly_CRC_SHIFT_q <<( `CRC_NUMBITS-`CRC_NUMPOLY+ `CRC_NUMPOLY); 
	cnt<=8'b0;
	strobe <= 1'b0;
	status<=`CRC_SHIFT;
	p<=10'd`CRC_NUMBITS+10'd`CRC_NUMPOLY;
end
`CRC_SHIFT:   begin 
	if(p_q>=`CRC_NUMPOLY) begin 
		if(data[p_q]==1'b1) begin
		   data <= data_q^poly_CRC_SHIFT;   //XOR, if bit is 1
      end begin end
			poly_CRC_SHIFT <= poly_CRC_SHIFT_q>>1'b1; 
			p<=p_q-10'b1; 
	end  else begin 
		status<=`CRC_DATA_STORE;
	end
end
`CRC_DATA_STORE: begin 
		status<=`CRC_STROBE ;
//       result_bits<=data_q[(`CRC_NUMPOLY-1):0]; 
			for(i=0;i<`CRC_NUMPOLY;i=i+1) begin
				result_bits[i]<=data_q[i] ;
			end
			cnt<=8'b0;
end
`CRC_STROBE: begin 
	if(cnt_q<= 8'd3) begin
		strobe <= 1'b1;
		cnt<=cnt_q+8'b1;
	   end else begin 
			status<=`CRC_STOP; 
		end 
end
`CRC_STOP: begin 
	strobe <= 1'b1;           
	busy=1'b0;
	if(reset==1'b1) status <= `CRC_IDLE;						
end
default: status<=`CRC_IDLE;
endcase
end
endmodule


//////////////////////////////////////////
module CreatePacket(data,serial_data,system_clock,ck,start,active,busy,strobe,bits_out);
input [`U8B13B_DATALENGTH_MSB:0] data; //255:0
input ck,start,active;
input system_clock;
output busy,strobe;
output [`U8B13B_BITLENGTH_MSB:0] serial_data;//
output bits_out;
reg [`U8B13B_BITLENGTH_MSB:0] serial_data,serial_data_q;//
reg [`U8B13B_DATABITLENGTH_MSB:0] data_body,data_body_q,data_body_crc,data_body_crc_q;//447:0
reg [`U8B13B_SEGMENT_MSB:0] seg,seg2;
reg [`U8B13B_DATALENGTH_MSB:0] data_store,data_store_q; //255:0
reg [4:0] status,status_q;
reg busy, strobe;
reg [15:0] preamble;
reg [9:0] p,p_q,pt,pt_q,pc;
reg bits_out;
reg tx_strobe, tx_start,tx_reset;
reg clk1,clk2,clk1_q,clk2_q;
integer i,j;
///////////////////////////////////////////////
reg crc_start,crc_reset;
wire [(`DATA_LENGTH+`CRC_NUMPOLY-1):0] data_crc,bits;//448+16 [(448+16-1):0]
reg  [(`DATA_LENGTH+`CRC_NUMPOLY-1):0] data_crc_store;//448+16 [(448+16-1):0]
wire  [(`CRC_NUMPOLY-1):0] crc_cof;//[(16-1):0]
reg [`U8B13B_CRCMAN_MSB:0] crc_cof_man;
wire crc_strobe;
/////////////////////////////////////////////
reg preamble_add=1'b0,preamble_add_q=1'b0;


initial begin
status<=`U8B13B_IDLE;
status_q<=`U8B13B_IDLE;
busy<=1'b0;
strobe<=1'b0;
preamble<=`U8B13B_PREAMBLE;
p = 10'b0;
p_q = 10'b0;
crc_start=1'b0;
crc_reset=1'b0;
data_crc_store=0;
tx_strobe=1'b0;
tx_start=1'b0;
tx_reset=1'b0;
clk1=1'b0;
clk2=1'b0;
clk1_q=1'b0;
clk2_q=1'b0;
preamble_add=1'b1;
preamble_add_q=1'b1;
end



///////////////////////////////////
CRC ID5 (
.data_in(data_body_crc), //input [`CRC_NUMBITS:0] data_in;[255:0]
.poly(`CRC_FACTOR),	//input [`CRC_NUMPOLY:0] poly;
.cof(`CRC_COF),		//input [`CRC_NUMPOLY-1:0] cof;
.start(crc_start),	//input start;
.ck(system_clock),//.ck(clk2),	//input ck system_cloc is 25MHz
.busy(crc_busy),		//output busy;
.result(crc_cof),		//output [(`CRC_NUMPOLY-1):0] result;
.strobe(crc_strobe),	//output strobe;
.bits(bits),		   //output [(`CRC_NUMBITS+`CRC_NUMPOLY):0] bits, bits_1;
.data_crc(data_crc),	//output [(`CRC_NUMBITS+`CRC_NUMPOLY):0] bits, bits_1;
.reset(crc_reset)		//input reset
);

///////////////////////////////////

always @(negedge ck)begin  p_q<=p; preamble_add_q<=preamble_add; end

always @(posedge ck) begin
case ({tx_start,tx_reset})
  ///TEST CODE Extended Preamble////
2'b00: begin  preamble_add=1'b1; end
2'b10: begin //SENDING
 	if((p_q<10'd`U8B13B_BITLENGTH+10'd40) && (p_q>=10'd`U8B13B_BITLENGTH)  ) begin
	   preamble_add<=~preamble_add_q;
		bits_out <=preamble_add_q;
		p <= p_q - 10'b1;
	end else begin
	if ( (p_q<10'd`U8B13B_BITLENGTH) && (p_q >= 10'd0)) begin
		bits_out <= serial_data[p_q];
		p <= p_q - 10'b1;
	end else begin 
		bits_out <= 1'b0;
		tx_strobe<=1'b1;
	end
	end
end
2'b01:begin //RESET
	p <=`U8B13B_BITLENGTH_MSB+10'd20;
	bits_out = 1'b0;
	tx_strobe<=1'b0;		
end
2'b11: begin end
endcase
end


always @(negedge  system_clock)  begin
serial_data_q<=serial_data;
data_store_q<=data_store;
data_body_q<=data_body;
data_body_crc_q<=data_body_crc;
pt_q<=pt;
status_q<=status;
end
//////////////////////////////////////
///////////// Create Packet //////////
//////////////////////////////////////
always @(posedge system_clock)  begin
case (status_q)
`U8B13B_IDLE: begin
   strobe<=1'b0;
	if(start==1'b1) begin 
		status=`U8B13B_INITIAL; 
		busy=1'b1; 
		crc_start<=1'b0;
		crc_reset<=1'b0;
	   strobe<=1'b0;
		tx_start<=1'b0;
      tx_reset<=1'b0;
	end  else begin 
		busy=1'b0;
		crc_start<=1'b0;
		crc_reset<=1'b1;
		tx_start<=1'b0;
      tx_reset<=1'b1;
	end

end
	 
`U8B13B_INITIAL: begin
	busy<=1'b1;
	status <= `U8B13B_CREATE_PREAMBLE;
	serial_data<=`U8B13B_BITLENGTH'b0;
end
	
`U8B13B_CREATE_PREAMBLE: begin	
	if(active==1'b1) begin
		serial_data<={preamble,4'b1111};
	end else begin
		serial_data<={preamble,4'b0};
	end
   status <= `U8B13B_CREATE_PREAMBLE_SHIFT;	
end

	
`U8B13B_CREATE_PREAMBLE_SHIFT: begin	
	serial_data<=serial_data_q<< (`U8B13B_BITLENGTH-(`NUM_PREAMBLE+`NUM_STARTBIT)) ;
	pt<=10'd`U8B13B_DATALENGTH ;
	data_store<=data;
	data_body    <=`U8B13B_DATABITLENGTH'd0;
	data_body_crc<=`U8B13B_DATABITLENGTH'd0;
	status <=`U8B13B_CREATE_BODY;
end
//////////////////////////////////////
////// ENCODE 8B13B //////////////////
//////////////////////////////////////
`U8B13B_CREATE_BODY: begin	
case({data_store_q[`U8B13B_DATALENGTH_MSB],data_store_q[`U8B13B_DATALENGTH_MSB-1],data_store_q[`U8B13B_DATALENGTH_MSB-2],data_store_q[`U8B13B_DATALENGTH_MSB-3],data_store_q[`U8B13B_DATALENGTH_MSB-4],data_store_q[`U8B13B_DATALENGTH_MSB-5],data_store_q[`U8B13B_DATALENGTH_MSB-6],data_store_q[`U8B13B_DATALENGTH_MSB-7]})
	`include<8B13BConvert.h>
            default: begin end
   endcase
	if(pt_q>10'd`U8B13B_SEGMENT_SRC) begin
		pt=pt_q-	10'd`U8B13B_SEGMENT_SRC;
		status<=`U8B13B_CREATE_BODY_SHIFT;
   end else begin 
		status<=`U8B13B_CREATE_CRC;
      crc_start<=1'b1;
		crc_reset<=1'b0;		
	end

end

`U8B13B_CREATE_BODY_SHIFT: begin	
   data_store<=data_store_q<<(`U8B13B_SEGMENT_SRC);
	data_body     <=data_body_q    <<(`U8B13B_SEGMENT);
	data_body_crc <=data_body_crc_q<<(`U8B13B_SEGMENT);
	status <=`U8B13B_CREATE_BODY;
end

//////////////////////////////////////
/////// 3bit Manchester //////////////
//////////////////////////////////////
`U8B13B_CREATE_CRC: begin
   if(crc_strobe==1'b1) begin
		status <= `U8B13B_CREATE_PACKET_0;
		data_crc_store<=data_crc;
		j=0;
		//3bit Manchester
		for(i=0;i<=15;i=i+1) begin ///////////////////CRC is converted to 48bit on 3bit Manchester Code.
			if(crc_cof[i]==1'b1) begin 
				crc_cof_man[j+2]=1'b0; 
				crc_cof_man[j+1]=1'b1; 
				crc_cof_man[j+0]=1'b0; 			
				end else begin 
				crc_cof_man[j+2]=1'b0; 
				crc_cof_man[j+1]=1'b0; 
				crc_cof_man[j+0]=1'b1; 			
			end
			j=j+3;
		end
	serial_data[(`U8B13B_BITLENGTH_MSB-`NUM_PREAMBLE-`NUM_STARTBIT):0]<={data_body[`U8B13B_DATABITLENGTH_MSB:0],crc_cof_man[`U8B13B_CRCMAN_MSB:0]};
	//	serial_data[(`U8B13B_BITLENGTH_MSB-`NUM_PREAMBLE-`NUM_STARTBIT):0]<={data_body[`U8B13B_DATABITLENGTH_MSB:0],crc_cof[`CRC_NUMPOLY-1:0]};////
	end else begin 
	end
end

`U8B13B_CREATE_PACKET_0: begin
	status <= `U8B13B_CREATE_PACKET_1;
	tx_start<=1'b1;
end

`U8B13B_CREATE_PACKET_1: begin
	status <= `U8B13B_SEND;
	tx_start<=1'b1;
end

`U8B13B_SEND: begin 
   if(tx_strobe==1'b1) begin
		status <= `U8B13B_TERMINATE;
		tx_start<=1'b0;
      tx_reset<=1'b1;
	end else begin 
	end
end
	  
  
`U8B13B_TERMINATE: begin 
	status<=`U8B13B_IDLE;	
   busy<=1'b0;	
	tx_start<=1'b0;
   tx_reset<=1'b0;
end
default: begin status<=`U8B13B_IDLE; end 
endcase
end

endmodule
///////////////////////////////////////////////////////

module DECODE8B13B ( 
input wire [`CRC_NUMBITS:0] data448_in,
output wire [`RECV_DATALENGTH_MSB:0] data_out,
input start, 
input reset,
input ck,
output decode_result,
output strobe
);
reg [8:0] value,value_q;
reg [11:0] p,p_q;
reg [3:0] decode_state,decode_state_q;
reg [`RECV_DATALENGTH_MSB:0] data,data_q;
reg [`CRC_NUMBITS:0] data448;
reg decode_strobe,decode_strobe_q,decode_ok;
wire decode_start,decode_reset;
assign data_out=data;
assign decode_start=start;
assign decode_reset=reset;
assign decode_result=decode_ok;
assign strobe=decode_strobe;

initial begin
	data_q   = `RECV_DATALENGTH'b0;   // [(`RECV_DATALENGTH_MSB+`CRC_NUMPOLY):0]
	data     = `RECV_DATALENGTH'b0;   // [(`RECV_DATALENGTH_MSB+`CRC_NUMPOLY):0]
	decode_state<=`DECODE_INITIAL;
	decode_state_q<=`DECODE_INITIAL;
	p<=`CRC_NUMBITS;
	p_q<=`CRC_NUMBITS;
end

function [8:0] U8B13BInvert(input[12:0] ubit);
case(ubit)
////This File is generated DEFINE.xlsx
`include<8B13BInvert.h>
	default: begin U8B13BInvert=9'b111111111; end
endcase
endfunction

always @(posedge ck) begin 
case (decode_state_q)
`DECODE_INITIAL: begin 
	decode_strobe<=1'b0;		
	decode_ok<=1'b0;
	p<=`CRC_NUMBITS;
	decode_state<=`DECODE_IDLE;
end
`DECODE_IDLE:begin 
	if(decode_start==1'b1) begin 
		decode_state<=`DECODE_CONV;
	   data448<=data448_in;	
	end else begin 
	end
end
`DECODE_CONV:begin 
value<=U8B13BInvert({data448[p_q],data448[p_q-1],data448[p_q-2],data448[p_q-3],data448[p_q-4],data448[p_q-5],data448[p_q-6],data448[p_q-7],data448[p_q-8],data448[p_q-9],data448[p_q-10],data448[p_q-11],data448[p_q-12]});
decode_state<=`DECODE_CALC;
end

`DECODE_CALC:begin //If you modify bit length such as  a 4B7B->8B13B, you need correct below and [3:0] to [7:0].
	if(value_q!=9'b111111111) begin 
		data[7:0]<=value_q[7:0];
		if (  p_q>`U8B13B_SEGMENT   ) begin 
			p<=p_q-`U8B13B_SEGMENT;
			data[`U8B13B_DATALENGTH_MSB:`U8B13B_SEGMENT_SRC]<=data_q[`U8B13B_DATALENGTH_MSB-`U8B13B_SEGMENT_SRC:0];
			decode_state<=`DECODE_CONV;
		end else begin 
			data[`U8B13B_DATALENGTH_MSB:`U8B13B_SEGMENT_SRC]<=data_q[`U8B13B_DATALENGTH_MSB-`U8B13B_SEGMENT_SRC:0];
			decode_ok<=1'b1;
			decode_state<=`DECODE_TERM; 
		end
	end else begin 
			decode_ok<=1'b0;
			decode_state<=`DECODE_TERM; 
	end	
end


`DECODE_TERM: begin 
   	decode_strobe<=1'b1;
		if(decode_reset==1'b1) begin 
			decode_state<=`DECODE_INITIAL; 
		end else begin 

		end
end
default: begin decode_state<=`DECODE_INITIAL; end
endcase
end


always @(negedge ck) begin 
data_q<=data;
decode_strobe_q<=decode_strobe;
p_q<=p;
decode_state_q<=decode_state;
value_q<=value;
end



endmodule

///////////////////////////////////////////////////////
module Deserializer (clkex,in_put,clk_out,sig_selector,data,strobe,c_wire,status_wire,
prev_sel_wire,now_sel_wire,FPGA_CLK1_50,ClockPLL,monostable,crc_error,in_reg,error_sw);

	input  clkex;
	input in_put;
   output [4:0] sig_selector;
	output clk_out;
	output [`RECV_DATALENGTH_MSB:0] data;
	output strobe;
   output c_wire;
	output [3:0] status_wire;
	output [4:0] prev_sel_wire;	
	output [4:0] now_sel_wire;
	output monostable;
	output [2:0] crc_error;
   output in_reg;
	input FPGA_CLK1_50;
	input ClockPLL;
	input error_sw;

	reg store_data;
	reg [3:0] status,status_q;
   reg [3:0] eddgecounter,eddgecounter_q;
	reg prev_data, now_data;
	reg [2:0] start_bit_count, start_bit_count_q,end_bit_count,end_bit_count_q;
	reg [`RECV_DATALENGTH_MSB:0] data,data_q,data_tmp;
	wire [`RECV_DATALENGTH_MSB:0] data_out;
	reg [`DATA_CRC_MAN_MSB:0] serial_data,serial_data_q,serial_data_store,serial_data_store_q;
	reg [`DATA_CRC_MSB:0] serial_data_16, data_crc_store,data_crc_store_q,data_crc_org;
	reg [`CRC_NUMBITS:0] data448,data448_q,data448_org;
	reg [6:0] ubit;
	reg [3:0] pos,pos_q;
	reg pos_led;
	reg store_strobe,store_strobe_q;
	reg clock,temp;
	wire clock_tmp;
	reg [7:0] waiting_start_bit,waiting_start_bit_q;
	reg c;
	reg in_reg,in_data;
	reg [7:0] count,count_q;
	reg monostable;
	reg [11:0] bit_counter,bit_counter_q,slr_counter,slr_counter_q,p,p_q;
	reg crc_start,crc_reset,crc_strobe_q,crc_ok,crc_ok_q;
	wire crc_busy,crc_strobe;
	wire [(`CRC_NUMPOLY-1):0] crc_cof;
	reg [(`CRC_NUMPOLY-1):0]  rec_cof,rec_cof_q;	
	reg decode_start,decode_start_q,decode_reset,decode_reset_q,decode_strobe_q,decode_ok_q;
	wire decode_ok,decode_strobe;
	reg [3:0] decode_state,decode_state_q;
	reg change_phase;

   integer i,j;
   wire  [(`DATA_LENGTH+`CRC_NUMPOLY-1):0]  data_crc,bits;
	reg [31:0] sigs,sigs_mono;
	wire [5:0] select_signal,select_signal_dll;
	reg [5:0] now_sel,prev_sel;
	reg [4:0] now_sel4,prev_sel4;
	reg [4:0] sig_selector;
	reg inc,minus,bitdata;
   wire clk_mid;
  	reg readbit,readbit_mono,readbit_pre,readbit_pre_mono;
	reg [7:0] strobe_counter,strobe_counter_q;
   reg  error_corr_ok, error_crc, error_pre,error_corr_ok_q, error_crc_q, error_pre_q; //  reg [2:0] error;  reg [2:0] error,error_q;
	reg [31:0] num_corr,num_corr_q,num_error,num_error_q,num_error_pre,num_error_pre_q;

assign c_wire =   sigs[sig_selector];
assign strobe=store_strobe; 
assign status_wire= status;
assign prev_sel_wire = prev_sel;
assign now_sel_wire = now_sel;
assign clk_out = clock;
assign crc_error={error_corr_ok,error_crc,error_pre};




CRC ID6 (
.data_in(serial_data_16[`DATA_CRC_MSB:`CRC_NUMPOLY]),  //data[(`DATA_LENGTH+`CRC_NUMPOLY-1):`CRC_NUMPOLY]), 		//input [`CRC_NUMBITS:0] data_in;
.poly(`CRC_FACTOR),	//input [`CRC_NUMPOLY:0] poly;
.cof(serial_data_16[(`CRC_NUMPOLY-1):0]),		//input [`CRC_NUMPOLY-1:0] cof;
.start(crc_start),	//input ck,start;
.ck(FPGA_CLK1_50),           //(FPGA_CLK1_50),	//input ck,start;
.busy(crc_busy),		//output strobe,busy;
.result(crc_cof),				//output [(`CRC_NUMPOLY-1):0] result;
.strobe(crc_strobe),	//output strobe,busy;
.bits(bits),		//output [(`CRC_NUMBITS+`CRC_NUMPOLY):0] bits, bits_1;
.data_crc(data_crc),		//
.reset(crc_reset)
);


DECODE8B13B ID7 (
.data448_in(data448), 		//input [`CRC_NUMBITS:0] data448_in;
.data_out(data_out), 		//output [`RECV_DATALENGTH_MSB:0] data_out;
.start(decode_start), 				//input start, reset,ck;
.reset(decode_reset) , 			//input start, reset,ck;
.decode_result(decode_ok),	//output decode_result,strobe;
.strobe(decode_strobe),//output decode_result,strobe;
.ck(FPGA_CLK1_50)//(FPGA_CLK1_50)	//input start, reset,ck;
);



initial begin
	in_reg = 1;
	count    = 8'b0;
	count_q  = 8'b0;
	status   = `INITIAL_RESET;
	status_q = `INITIAL_RESET; 
	monostable = 1'b0;
	data_q   = `RECV_DATALENGTH'b0;  
	data     = `RECV_DATALENGTH'b0; 
	bit_counter_q=12'b0;
	bit_counter=12'b0;
	waiting_start_bit=8'b0;
	waiting_start_bit_q=8'b0;
	start_bit_count=3'b0;
	start_bit_count_q=3'b0;
	end_bit_count=3'b0;
	end_bit_count_q=3'b0;
	eddgecounter  =4'b0;
	eddgecounter_q=4'b0;
	decode_state<=`DECODE_INITIAL;
	decode_state_q<=`DECODE_INITIAL;
	error_corr_ok=1'b0;	error_corr_ok_q=1'b0;
   error_crc=1'b0;	error_crc_q=1'b0;
   error_pre=1'b0;	error_pre_q=1'b0;
	inc=1'b0;
	minus=1'b0;
	bitdata=1'b0;
	serial_data=`DATA_CRC_MAN'b0;
	serial_data_q=`DATA_CRC_MAN'b0;
	store_strobe=1'b0;
	store_strobe_q=1'b0;
	strobe_counter=8'b0;
	strobe_counter_q=8'b0;
	num_corr=32'b0; num_corr_q=32'b0;
	num_error=32'b0;num_error_q=32'b0;
	num_error_pre=32'b0;num_error_pre_q=32'b0;
end



//////// Rewrote by T.Yukiya 2021.09.30 ///////////////////
always@(negedge ClockPLL) begin count_q<=count; end
///////////////////////////////////////////
//////// Monostable multivibrator /////////
///////////////////////////////////////////
always@(posedge ClockPLL) begin
	if({in_reg,in_put} == 2'b01) begin
		count = 8'd13;///Normal is 13
		monostable = 1'b1;
		end else begin 
			if(count_q >= 8'b1) begin
				count = count_q - 8'b1;
			end else begin
				monostable = 1'b0;
			end
		end
	in_reg = in_put;
end

Divider8Shift ID_CLKOUT_D2 (.clk(ClockPLL), .sig(clk), .accel(inc), .delay(minus));

always @(posedge ClockPLL) begin temp<=clk; end
always @(posedge ClockPLL) begin clock<=temp; end


function [31:0] SignalShift_fx(input[31:0] sigs, input in_data); // Negative Edge
begin
SignalShift_fx= sigs << 1;
SignalShift_fx[0]=in_data;
end
endfunction

always @(posedge ClockPLL) begin
sigs<=SignalShift_fx(sigs,in_reg);
sigs_mono<=SignalShift_fx(sigs_mono,monostable);
end


Divider2 ID_CO3 (.clk(clk),.sig(halfclock));
DelaySelector32 ID_CO4 (.clk(clk),.sigs(sigs_mono),
							.sel(select_signal),.twice_sig(halfclock),
								.lock(lock));
DelaySelector32 ID_CO5 (.clk(clk),.sigs(sigs_mono),
							.sel(select_signal_dll),.twice_sig(clk),
								.lock(lock_dll));
								

function U3B1B(input[2:0] data_in  );
case(data_in)
	3'b000: begin 	 U3B1B=1'b0; end //DUMMY
	3'b001: begin   U3B1B=1'b0; end
	3'b010: begin   U3B1B=1'b1; end
	default: begin  U3B1B=1'b1; end
endcase
endfunction



always @(negedge clock ) begin 
crc_strobe_q<=crc_strobe;
crc_ok_q<=crc_ok;
decode_strobe_q<=decode_strobe;
decode_ok_q<=decode_ok;
status_q<=status; // Keep the status
bit_counter_q<=bit_counter;
waiting_start_bit_q <=waiting_start_bit;
start_bit_count_q   <=start_bit_count;
end_bit_count_q     <=end_bit_count;
eddgecounter_q      <=eddgecounter;
rec_cof_q<=rec_cof;
data448_q<=data448;
serial_data_store_q<=serial_data_store;
serial_data_q<=serial_data;
strobe_counter_q<=strobe_counter;
store_strobe_q<=store_strobe;
num_corr_q<=num_corr;
num_error_q<=num_error;
num_error_pre_q<=num_error_pre;
error_corr_ok_q<=error_corr_ok;
error_crc_q<=error_crc;
error_pre_q<=error_pre;
end

always @(posedge clock  ) begin  	

case (status_q) ///////////// STATE MACHINE FOR RECEIVE//////////
`INITIAL_RESET: begin 
	if(halfclock==1'b1 && lock==1'b1) begin
		prev_sel = select_signal;
		if(select_signal!=6'b111111&&(sigs_mono[select_signal[4:0]]==1'b1))  begin 

			status =`DETECT_INDATA;
			decode_start=1'b0; decode_reset=1'b1;
			crc_start<=1'b0;	 crc_reset<=1'b1;
		end else begin end
		sig_selector = 5'b0;
		eddgecounter = 4'b0;
		store_strobe = 1'b0;
		start_bit_count =3'b0;
		prev_sel=6'b0;
		crc_ok=1'b0;
	   error_corr_ok=1'b0;
      error_crc=1'b0;
      error_pre=1'b0;
	end else begin end

end

///////////////////////////////////////////////////////////////////////////////
//////////////// Be Careful!!! Blocking and nonblocking assign are mixed.//////
`DETECT_INDATA: begin
	if(clock==1'b1 &&  halfclock==1'b1 && lock==1'b1) begin
		now_sel = select_signal;
		store_strobe = 1'b0; 
		if(prev_sel!=6'b111111&&(sigs_mono[select_signal[4:0]]==1'b1))  begin 
			status <= `PREAMBLE_CHECK; 
			eddgecounter<= 4'b1; 
		end
	end else begin end
end

///////////////////////////////////////////////////////////////////////////////
//////////////// Be Careful!!! Blocking and nonblocking assign are mixed.//////
`PREAMBLE_CHECK: begin //Preamble Check (Sync)
   minus<=1'b0;
   inc<=1'b0;
	if(clock==1'b1 &&  halfclock==1'b1 && lock==1'b1) begin

		if(select_signal != 6'b111111&&(sigs[select_signal[4:0]]==1'b1)) begin
			prev_sel<=now_sel; 
   		now_sel4<=select_signal[4:0];//   { now_sel[3], now_sel[2], now_sel[1], now_sel[0]};
			prev_sel4={prev_sel[4],prev_sel[3],prev_sel[2],prev_sel[1],prev_sel[0]};
			///////////////////////////////////////
			//////// Clock Shift //////////////////
			///////////////////////////////////////
			if(select_signal[4:0]<=5'd12) minus<=1'b1; else minus<=1'b0;
			if(select_signal[4:0]>=5'd20) inc<=1'b1;  else inc<=1'b0;
				eddgecounter <= eddgecounter_q + 4'd1;
				if(eddgecounter_q >=4'd4) begin //minus 1 4'd5-> 4'd4
					status<= `BLANK ; 
					waiting_start_bit<=8'b0;
					start_bit_count<=3'b0;	
					end_bit_count<=3'b0;
					sig_selector <= select_signal[4:0]; 
				end else begin
			   end
		end else begin status <=  `INITIAL_RESET ;  eddgecounter<= 4'b0; error_pre=1'b1; end
	end else begin end
	end 

`BLANK: begin 
			status<= `COUNTING_START_BIT_0 ; 
			minus=1'b0;inc<=1'b0;
   end
	
`COUNTING_START_BIT_0: begin
if( waiting_start_bit_q< `COUNT_START_BIT_ERROR) begin
	if(sigs[sig_selector]==1'b1) begin 
		status<= `COUNTING_START_BIT_1; 
   	store_data<=1'b1 ;
	end else begin
   	store_data<=1'b0 ;
   	status<=`COUNTING_START_BIT_0;
   	waiting_start_bit<=waiting_start_bit_q+8'b1;
   end
end  else begin 
    	status <=  `INITIAL_RESET ;
		store_strobe <= 1'b0;  // Bad end 
end
   
end	
`COUNTING_START_BIT_1: begin
   if(sigs[sig_selector]==1'b1 & store_data==1'b1 ) begin 
   			store_data<=1'b1 ;
   			status<= `COUNTING_START_BIT_2; 	
   		end else begin 
   			store_data<=1'b0 ;
   			status <= `COUNTING_START_BIT_0; 
   		   waiting_start_bit=waiting_start_bit_q+8'b1;
   	end
   end 	
`COUNTING_START_BIT_2: begin
   if(sigs[sig_selector]==1'b1 & store_data==1'b1 ) begin  
   			store_data<=1'b1 ;
   			status<= `COUNTING_START_BIT_3; 	
   		end else begin 
   			store_data<=1'b0 ;
   			status <= `COUNTING_START_BIT_0; 
            waiting_start_bit=waiting_start_bit_q+8'b1;
   	end
   end
 `COUNTING_START_BIT_3: begin
   if(sigs[sig_selector]==1'b1 & store_data==1'b1 ) begin  
   		store_data<=1'b1;
   		status    <=`RECEIVE_DATA_0;		
         serial_data  <=`DATA_CRC_RESET;
			pos       <=3'b0;
			bit_counter<=12'b0;
			decode_reset<=1'b0;
			decode_start<=1'b0;
			crc_start<=1'b0;
			crc_reset<=1'b0;
   		end else begin 
   			store_data<=1'b0 ;
   			status <= `COUNTING_START_BIT_0; 
            waiting_start_bit<=waiting_start_bit_q+8'b1;
   	end
	end


`RECEIVE_DATA_0: begin  /// Receive Data 
minus=1'b0;
inc=1'b0;
serial_data[0]       =sigs_mono[sig_selector];   //Adding Serrial Data 
serial_data_store[0] =sigs_mono[sig_selector];
bit_counter<=bit_counter_q+12'b1; 
if(bit_counter_q<`DATA_CRC_MAN_MSB) begin 
	serial_data=serial_data<<1;
	serial_data_store=serial_data_store<<1;
   ///////////////////////////////////////
	///////////////// DLL /////////////////
	///////////////////////////////////////
	if(lock_dll==1'b1&&sigs_mono[sig_selector]==1'b1&&select_signal_dll != 6'b111111) begin 
	sig_selector = select_signal_dll[4:0];
	change_phase=1'b1;
	///////////////////////////////////////
	//////// Clock Shift //////////////////
	///////////////////////////////////////
	if(select_signal_dll[4:0]<=5'd2) minus=1'b1; else minus=1'b0; 
	if(select_signal_dll[4:0]>=5'd29) inc=1'b1; else  inc=1'b0;
	end else begin end
	
	end else begin

	for(i=0;i<`U8B13B_CRCMAN;i=i+3) begin
	   rec_cof=rec_cof>>1;
      rec_cof[(`CRC_NUMPOLY-1)]=U3B1B({serial_data[i+2],serial_data[i+1],serial_data[i]});
	end

  serial_data_16={serial_data[`DATA_CRC_MAN_MSB:`U8B13B_CRCMAN],rec_cof};
//  serial_data_16={serial_data[`DATA_CRC_MAN_MSB:`U8B13B_CRCMAN],rec_cof}^`DATA_CRC'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000;
//  serial_data_16={serial_data[`DATA_CRC_MAN_MSB:`U8B13B_CRCMAN],rec_cof}^`DATA_CRC'h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090000;
  status<=`RECEIVE_DATA_1;
end
end


///////////////////////////////////////////////////////////////////////
`RECEIVE_DATA_1:begin 
	crc_start<=1'b1;
	crc_reset<=1'b0;
	error_corr_ok=1'b0;	
   error_crc=1'b0;
   error_pre=1'b0;
	minus<=1'b0;
   inc<=1'b0;
	status<=`RECEIVE_DATA_2;
end
///////////////////////////////////////
///////// Receive Data ////////////////
///////////////////////////////////////
`RECEIVE_DATA_2: begin  /// Receive Data 
	if(crc_strobe_q==1'b1) begin
	// Normal end
   	status <= `DECODING_0;
		crc_start<=1'b0;

		if(crc_cof[15:14]==2'b00) begin
		case (crc_cof)
			16'b0000000000000000:begin data_crc_store<=data_crc ;  crc_ok<=1'b1;error_corr_ok<=1'b0; end
			`include "Table845_b00.h"
			default: begin error_crc<=1'b1; crc_ok <= 1'b0;  end
		endcase
		end else if(crc_cof[15:14]==2'b01) begin
		case (crc_cof)
			`include "Table845_b01.h"
			default: begin error_crc<=1'b1; crc_ok <= 1'b0;  end
		endcase		
		end else if(crc_cof[15:14]==2'b10) begin
			case (crc_cof)
			`include "Table845_b10.h"
			default: begin error_crc<=1'b1; crc_ok <= 1'b0;  end
		endcase
		end else begin 
		case (crc_cof)
			`include "Table845_b11.h"
			default: begin error_crc<=1'b1; crc_ok <= 1'b0;  end
		endcase		
		end				
	end
end

`DECODING_0: begin
data448_org<=data_crc_store[`DATA_CRC_MSB:`CRC_NUMPOLY];	
data448<=data_crc_store[`DATA_CRC_MSB:`CRC_NUMPOLY];	
status <= `DECODING_1;
/////////////// Amount Error ////////////////////
	if(error_corr_ok_q==1'b1) num_corr=num_corr_q+32'b1;       // Success to correct
	if(error_crc_q==1'b1) num_error=num_error_q+32'b1;         // Reciev error
	if(error_pre_q==1'b1) num_error_pre=num_error_pre_q+32'b1; //Preamble error	
end

`DECODING_1: begin
decode_start<=1'b1; decode_reset<=1'b0;
status <= `DECODING_2;
end

`DECODING_2: begin
	if(decode_strobe_q==1'b1) begin
	   decode_start<=1'b0;
		if(crc_ok==1'b1   && decode_ok==1'b1 ) begin // If crc_ok_q and decode_ok_q are used, SPI doesn't work.
			if(error_sw==1'b0)  begin 
					data<=data_out; //<- If "data_out" input into "data", SPI doesn't work.
			end else begin
					data[`RECV_DATALENGTH_MSB:96]<=data_out[`RECV_DATALENGTH_MSB:96];
					data[95:0] <={ num_corr, num_error,num_error_pre };					
			end
			store_strobe<=1'b1; // Caution: strobe and update data is same time. store_strobe_q is suitable?
		end else begin 
			store_strobe<=1'b0;
		end
			status<=`PRETERMINATE;
			strobe_counter<=8'b0;
			crc_reset<=1'b1; //Reset CRC Module
		end else begin 
	
	end	

end

		
`PRETERMINATE: begin  // Reset Strobe Signal
	if(strobe_counter>=`PW_REQ) begin
		status <=  `TERMINATE; 
		crc_reset<=1'b1;
	end else begin
		strobe_counter<=strobe_counter_q+8'b1;
	end
end	
		
//////////////////////////////////////////////////////////////
`TERMINATE: begin  // Reset Strobe Signal
	store_strobe <= 1'b0; 
	crc_reset<=1'b0;
	status <=  `INITIAL_RESET; 

end
//////////////////////////////////////////////////////////////
		
default: begin
	eddgecounter<= 4'b0;
	status <= `INITIAL_RESET ;
	store_strobe <= 1'b0; 
	end_bit_count<=3'b0;
	c<=1'b0;
	pos_led <=0;
end
		
endcase
		
		
end
	
endmodule

////////////////////////////////////////////////

module DE0NanoSoc_TXRX(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_SCK,
	output		          		ADC_SDI,
	input 		          		ADC_SDO,

	//////////// ARDUINO //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW,

	
	//////////// GPIO_0, GPIO connect to GPIO Default //////////
	output 		    [34:14]		GPIO_0GPIO,

	output        MISO,  //MISO GPIO0_PIN1      GPIO_0[0] V12
	input         MOSI,  //MOSI GPIO0_PIN2      GPIO_0[1] AF7
	input         SCLK0, //SCLK GIPO0_PIN3      GPIO_0[2] W12
	input         SS,    //SS GIPO0_PIN4        GPIO_0[3] AF8
   input         RESET, //RESET GIPO0_PIN5     GPIO_0[4] Y8
   output         START_SIG,   //GPIO0_PIN6    GPIO_0[5] AB4
	output         busy,    //GPIO0_PIN7		  GPIO_0[6] W8
	output         in_data, //GPIO0_PIN8		GPIO_0[7] Y4
	output         clk_out, //GPIO0_PIN9		GPIO_0[8] Y5
	output         recive_req_sig,//strobe,  //GPIO0_PIN10		GPIO_0[9] U11
	output         strobe2,  //AE12
	output         clock,   //GPIO0_PIN13		GPIO_0[10] T8
	input          receve_serial , //GPIO0_PIN14	GPIO_0[11] T12
	output         data_req_sig,  //GPIO0_PIN15 GPIO_0[12] AH5,
	output          F_wire,
	output monostable_result,
	//////////// GPIO_1, GPIO connect to GPIO Default //////////
	output 		    [35:0]		GPIO_1GPIO
	
	
);


//=======================================================
//  REG/WIRE declarations
//=======================================================
reg data_req;
reg  txrx_phase;
reg i_have_packet,spi_reset;
reg  [`U8B13B_DATALENGTH_MSB:0] ret_val; //,buf_r;
wire [`U8B13B_DATALENGTH_MSB:0] led_sig, data_out ;
wire mosi,CS,SCLK,RST_N,RST, done;
wire miso, new_data;
reg miso_reg,done_reg;
reg active_r,F,clear,c;
reg [3:0]spi_recv_state,spi_recv_state_q;
reg start;
reg [`U8B13B_DATALENGTH_MSB:0] data_reg;
wire [15:0] op;
wire [3:0] status;
wire [4:0] prev_sel,now_sel;
wire enable;
wire serial_out;
wire [`U8B13B_DATALENGTH_MSB:0] data32,led_sig_wire,data_reg_wire;
reg [3:0] strobe_state=4'b0,strobe_state_q=4'b0;
reg [31:0] counter;
reg [7:0] LED_REG,data_req_counter=8'b0,strobe_req_counter=8'b0,data_req_counter_q=8'b0,strobe_req_counter_q=8'b0;
reg strobe_latch, recive_req;
wire delay_serial0,delay_serial1,delay_serial2,delay_serial3,delay_serial4,delay_serial5;
wire [`U8B13B_BITLENGTH_MSB:0] createpacket_serial_data;
wire createpacket_storobe;
wire [15:0] createpacket_bit_count;
wire monostable;
wire [2:0] error;
wire SysClock0,SysClock1,SysClock2,SysClock3,SysClock4;
wire ClockPLL0,ClockPLL1;
wire [31:0] num_error,num_corr;
wire in_reg;
reg [3:0] cnt_timing_q,cnt_timing;
reg clk3, clk3_q;
reg [3:0] sw_q;
reg record_strobe;
wire clk50;
wire clk25;
assign monostable_result = monostable;

//=======================================================
//  Structural coding
//=======================================================



	ClockBridge u0 (
		.pll_0_locked_export          (GPIO_1GPIO[1]),          //             pll_0_locked.export
		.pll_0_reset_reset            (1'b0),            //              pll_0_reset.reset
		.pll_0_refclk_clk             (FPGA_CLK2_50),             //             pll_0_refclk.clk
		.clock_bridge_1_out_clk_clk   (ClockPLL0),   // 100MHz clock_bridge_1_out_clk.clk
		.clock_bridge_1_out_clk_1_clk (ClockPLL1),   // 100MHz clock_bridge_1_out_clk_1.clk
		.clock_bridge_1_out_clk_2_clk (ClockPLL2),   // 100MHz clock_bridge_1_out_clk_2.clk
		.clock_bridge_1_out_clk_3_clk (ClockPLL3),   // 100MHz clock_bridge_1_out_clk_3.clk
		.clock_bridge_0_in_clk_clk    ( clk25 ),    //    clock_bridge_0_in_clk.clk
		.clock_bridge_0_out_clk_clk   (SysClock0),   //   clock_bridge_0_out_clk.clk
		.clock_bridge_0_out_clk_1_clk (SysClock1), // clock_bridge_0_out_clk_1.clk
		.clock_bridge_0_out_clk_2_clk (SysClock2), // clock_bridge_0_out_clk_2.clk
		.clock_bridge_0_out_clk_3_clk (SysClock3),  // clock_bridge_0_out_clk_3.clk
		.clock_bridge_2_in_clk_clk    (FPGA_CLK2_50),    // 50MHz   clock_bridge_2_in_clk.clk
		.clock_bridge_2_out_clk_clk   (clk50)       //  50MHz  clock_bridge_2_out_clk.clk
	);	

Divider4 ID_CLK25 (.clk(ClockPLL0),.sig(clk25)); //100MHz/8=12.5MHz 80ns
Divider8 ID_DIV4_RECV (.clk(ClockPLL0),.sig(base_clk)); //BaseClock
Divider8 ID_DIV4_SEND (.clk(ClockPLL3),.sig(base_clk_send)); //BaseClock


//CLOCK_CH ID0 (ClockPLL0 ,op);

CreatePacket ID1(
.data(data_reg), 
.serial_data(createpacket_serial_data),
.system_clock(SysClock3),
.ck(base_clk_send),
.start(start),
.active(active_r),
.busy(busy),
.strobe(createpacket_storobe),
.bits_out(in_data)
);

  
  spi_slave ID_SLAVE(
    .clk   (clk50),//(FPGA_CLK2_50),// (FPGA_CLK1_50),           // input clk,
    .rst   (1'b0),  //(RESET),  // input rst, // 1 is reset , 0 is no reset. Be careful!!!
    .ss    (CS),    //input ss,   //Slave Select 0 is active!
    .mosi   (mosi),
    .miso   (miso),          //output miso,
    .sck    (SCLK),           //  input sck,
    .done   (DONE),          //    output done,
    .din    (ret_val),    //(32'haaaaaaaa), //(ret_val),   //.din    (ret_val),     //   input [7:0] din,
    .dout    (led_sig), //output [7:0] dout
    .cpol   (SW[1]),
	 .cpha   (SW[0])
);
  
  
assign strobe2=1'b1;
assign  data_req_sig=data_req;
assign  F_wire=F;
assign  mosi =  MOSI;
assign  CS =    SS;
assign  SCLK =  SCLK0;
assign  done = DONE;
assign  led_sig_wire = led_sig;
assign  data_reg_wire = data_reg;
assign  recive_req_sig= recive_req;
assign  MISO = miso ;

DelayFF ID_Delay0(receve_serial,delay_serial0,ClockPLL0);
DelayFF ID_Delay1(delay_serial0,delay_serial1,ClockPLL0);

Deserializer ID3 (base_clk,delay_serial1,clk_out,sig_sel,data32,strobe,clock,status,
  prev_sel,now_sel,SysClock1,ClockPLL0,monostable,error,in_reg,SW[2]);




//	assign GPIO_1GPIO[0]     = data32[0];
//	assign GPIO_1GPIO[1]     = data32[1];
//	assign GPIO_1GPIO[2]     = data32[2];
//	assign GPIO_1GPIO[3]     = data32[3];
//	assign GPIO_1GPIO[4]     = data32[4];
//	assign GPIO_1GPIO[5]     = data32[5];
	assign GPIO_1GPIO[6]     = data32[6];
	assign GPIO_1GPIO[7]     = data32[7];
	assign GPIO_1GPIO[8]     = data32[8];
	assign GPIO_1GPIO[9]     = data32[9];
	assign GPIO_1GPIO[10]     = data32[10];
	assign GPIO_1GPIO[11]     = data32[11];
	assign GPIO_1GPIO[12]     = data32[12];
	assign GPIO_1GPIO[13]     = data32[13];
	assign GPIO_1GPIO[14]     = data32[14];
	assign GPIO_1GPIO[15]     = data32[15];
	
   assign START_SIG = start;
	assign LED[7:0] = LED_REG[7:0]; 
   assign GPIO_1GPIO[16] = FPGA_CLK3_50 ; //GPIO_1_PIN19
   assign GPIO_1GPIO[17] = strobe ; //GPIO_1_PIN19  
   assign GPIO_1GPIO[25] = createpacket_storobe ; //GPIO_1_PIN28
   assign GPIO_1GPIO[27] = ClockPLL0 ; //GPIO_1_PIN32
	assign GPIO_1GPIO[31] = ClockPLL1 ; //GPIO_1_PIN36
	assign GPIO_1GPIO[32] = SysClock3 ; //GPIO_1_PIN37
	assign GPIO_1GPIO[33] = clear    ; //GPIO_1_PIN38
	assign GPIO_1GPIO[34] = base_clk    ; //GPIO_1_PIN39
	assign GPIO_1GPIO[35] = in_reg    ; //GPIO_1_PIN40
//	assign GPIO_1GPIO[31:17] = 15'b0;	
	
	
initial begin
	counter = 32'b0;
	start  = 1'b0;
	active_r = 1'b0;
	clear = 1'b0;
	data_reg =`RECV_DATALENGTH'b0; 
	F=1'b0;
	strobe_state_q=4'd0;
	strobe_state=4'd0;
	strobe_req_counter=8'b0;
	strobe_req_counter_q=8'b0;
	record_strobe=1'b0;
	spi_recv_state=4'd0;
	i_have_packet=1'b0;
	spi_reset=1'b0;
	cnt_timing_q=4'b0;
	cnt_timing=4'b0;
   clk3_q=1'b0;
	clk3=1'b0;
	sw_q=4'b0;
end
	

always @(  status or CS or  strobe)
begin
LED_REG[0] <= status[0]; // If signal = 1 , LED is lighting.
LED_REG[1] <= status[1]; 
LED_REG[2] <= status[2]; 
LED_REG[3] <= status[3]; 
if(CS == 1'b0) LED_REG[4] <= 1'b1; else LED_REG[4] <= 1'b0; 
if(status== `RECEIVE_DATA_0)   LED_REG[5] <= 1'b1; else LED_REG[5] <= 1'b0;
LED_REG[6] <= KEY[0];
LED_REG[7] <= strobe;
end




always @(done) begin done_reg<=done; end



/////////////PLL/////////////////////////////////////
always @(negedge  base_clk) begin  			  //
cnt_timing_q=cnt_timing;
clk3_q=clk3;								           //
end															//
always @(posedge  base_clk) begin  			   //
 if(cnt_timing_q>=4'd1) begin 						//
	cnt_timing=4'd0; 									//
	clk3=~clk3_q;											//
end else begin 											//
	cnt_timing=cnt_timing_q+4'b1;					//
end															//
end															//
/////////////////////////////////////////////////////


////////////////////////////////////
/// Timing Controller  For SPI /////
////////////////////////////////////
always @(negedge base_clk) begin 
	spi_recv_state_q<=spi_recv_state; 
	data_req_counter_q<=data_req_counter;
end

always @(posedge base_clk) begin

if(sw_q[3]==0) begin // 0 means send , 1 means recv.
	if(clear==1'b1) begin 
		spi_recv_state<=4'd0;
		data_req<=1'b0;
		active_r<=1'b0; 
	end else begin 
		case (spi_recv_state_q)
		`SPI_SEND_INIT:begin  
				active_r<=1'b0; 
				data_req<=1'b0; 
				data_reg <= `RECV_DATALENGTH'b0; 
				spi_recv_state=`SPI_SEND_WAIT; 
			end
		`SPI_SEND_WAIT:begin 
			if(txrx_phase==`TXRX_SEND_PKT) begin 
					spi_recv_state<=`SPI_SEND_DATA_REQ1;
					data_req<=1'b1;   ///// Data_REQUEST_SIGNAL FOR RASPBERRY
					data_req_counter=8'b0;
			end else begin 
				spi_recv_state<=`SPI_SEND_WAIT; 
			end
		end
 
		`SPI_SEND_DATA_REQ1:begin
			if(data_req_counter_q>=`PW_REQ) begin
				spi_recv_state<=`SPI_SEND_DATA_REQ2; 
			end else begin 
				data_req_counter<=data_req_counter_q+1'b1;
			end
		end
		`SPI_SEND_DATA_REQ2:begin  
		    spi_recv_state<=`SPI_SEND_WAIT_DONE0;
			 data_req<=1'b0;  
		end
 
		`SPI_SEND_WAIT_DONE0:begin 
			`ifdef DEBUG_SEND
					 spi_recv_state<=`SPI_SEND_PREEND0; 
					 data_reg = `U8B13B_DATALENGTH'h000f1e1d3c4b5a69788796a5b4c3d2e1f00f1e1d3c4b5a69788796a5b4c3d2e1f00f1e1d3c4b5a69788796a5b4c3d2e1f00f1e1d3c4b5a69788796a5b4c3d2e1f0; 
			`else
				if(done_reg==1'b1) begin 
					 spi_recv_state<=`SPI_SEND_PREEND0; 
					 data_reg<=led_sig; 
				end else begin 
					 spi_recv_state<=`SPI_SEND_WAIT_DONE0; 
				end
			`endif
		end
		`SPI_SEND_PREEND0: begin spi_recv_state<=`SPI_SEND_PREEND1;  end
		`SPI_SEND_PREEND1: begin
			active_r<=1'b1;
			spi_recv_state<=`SPI_SEND_END; 
	   end
		`SPI_SEND_END: begin 
			if(txrx_phase==`TXRX_RECV_SPI) begin 
				spi_recv_state<=`SPI_SEND_INIT; // To Initial 
			end else begin 
				spi_recv_state<=`SPI_SEND_END; 
			end
		end
		default: begin spi_recv_state<=`SPI_SEND_INIT; end
		endcase
	end 
end else begin 
	data_req<=1'b0; 
	active_r<=1'b0;
	spi_recv_state<=4'd0;	
end
end

////////////////////////////////////
/// Timing Controller  /////////////
////////////////////////////////////
//////Timing is depend on responsivity of raspberry-pi.
always @( posedge clk3) begin
	case (counter) 
/* 20230227 Stable BCM2835LIB for Poling method.
	32'd0:  begin start <= 1'b0;
				clear <= 1'b0; 
				//SW==0 is send_recv , SW==1 is recv only
				//txrx_phase=`TXRX_SEND_PKT; 
				end
	32'd1: begin txrx_phase=`TXRX_SEND_PKT; end
	32'd8500: begin if(sw_q[3]==0) start <= 1'b1; else start <= 1'b0; end // Must be finished SPI RECV until 10000./11050//9000 NoMiss 
	32'd8550: begin start <= 1'b0;  end  //11050 //9050 NoMiss 
	32'd9000: begin txrx_phase=`TXRX_RECV_SPI; end //32'd13000: 32'd9500:
	32'd10500: begin clear <= 1'b1;  end //32'd38500:32'd10000:
	default: begin end
	
	endcase 
	
	counter = counter +32'b1;
	if(counter>=32'd10600) begin counter=32'b0; clear<=1'b0; end //32'd38600 32'd18600(BCM2835LIB)
*/
/*Stable 2023 03 31 For Alert of PIGPIO*/
	32'd0:  begin start <= 1'b0;
				clear <= 1'b0; 
				//SW==0 is send_recv , SW==1 is recv only
				//txrx_phase=`TXRX_SEND_PKT; 
				end
	32'd1: begin txrx_phase=`TXRX_SEND_PKT; end
	32'd11000: begin if(sw_q[3]==0) start <= 1'b1; else start <= 1'b0; end // Must be finished SPI RECV until 10000./11050//9000 NoMiss 
	32'd11050: begin start <= 1'b0;  end  //11050 //9050 NoMiss 
	32'd13000: begin txrx_phase=`TXRX_RECV_SPI; end //32'd13000: 32'd9500:
	32'd38500: begin clear <= 1'b1;  end //32'd38500:32'd10000:
	default: begin end
	
	endcase 
	
	counter = counter +32'b1;
	if(counter>=32'd38600) begin counter=32'b0; clear<=1'b0; end //32'd38600 32'd18600(BCM2835LIB)
end




always @(negedge base_clk) begin sw_q<=SW; end

///////////////////////////////////
///////  Timing Controller ////////
///////////////////////////////////
// If strobe == 1, data is copied to ret_val as SPI MISO////////
// 2021.09.16 T.YUKIYA
always @( posedge base_clk  ) begin
if(sw_q[3]==1) begin // 0 means send , 1 means recv.
	if(strobe==1'b0) begin 
		i_have_packet<=1'b0;
		recive_req<=1'b0;
	end else begin
		i_have_packet<=1'b1;
		recive_req<=1'b1;
		ret_val<=data32; 
	end
end else begin 
		i_have_packet<=1'b0;
		recive_req<=1'b0;
end
end	

endmodule